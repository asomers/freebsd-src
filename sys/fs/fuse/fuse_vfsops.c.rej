@@ -576,47 +575,10 @@
 	error = fuse_vnode_get(mp, feo, nodeid, NULL, vpp, NULL, vtyp);
 	if (error)
 		goto out;
-	filesize = feo->attr.size;
-
-	/*
-	 * In the case where we are looking up a FUSE node represented by an
-	 * existing cached vnode, and the true size reported by FUSE_LOOKUP
-	 * doesn't match the vnode's cached size, then any cached writes beyond
-	 * the file's current size are lost.
-	 *
-	 * We can get here:
-	 * * following attribute cache expiration, or
-	 * * due a bug in the daemon, or
-	 */
 	fvdat = VTOFUD(*vpp);
-	if (vnode_isreg(*vpp) &&
-	    filesize != fvdat->cached_attrs.va_size &&
-	    fvdat->flag & FN_SIZECHANGE) {
-		if (data->cache_mode == fuse_data_cache_mode) {
-			const char *msg;
-
-			if (fuse_libabi_geq(data, 7, 23)) {
-				msg = "writeback cache incoherent!."
-				    "To prevent data corruption, disable "
-				    "the writeback cache according to your "
-				    "FUSE server's documentation.";
-			} else {
-				msg = "writeback cache incoherent!."
-				    "To prevent data corruption, disable "
-				    "the writeback cache by setting "
-				    "vfs.fusefs.data_cache_mode to 0 or 1.";
-			}
-			fuse_warn(data, FSESS_WARN_WB_CACHE_INCOHERENT, msg);
-		} else {
-			/* If we get here, it's likely a fusefs kernel bug */
-			printf("%s: WB cache incoherent on %s!\n", __func__,
-			    vnode_mount(*vpp)->mnt_stat.f_mntonname);
-		}
-		fvdat->flag &= ~FN_SIZECHANGE;
-	}
 
 	fuse_internal_cache_attrs(*vpp, &feo->attr, feo->attr_valid,
-		feo->attr_valid_nsec, NULL);
+		feo->attr_valid_nsec, NULL, true);
 	fuse_validity_2_bintime(feo->entry_valid, feo->entry_valid_nsec,
 		&fvdat->entry_cache_timeout);
 out:
